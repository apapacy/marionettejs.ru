Сокращает повторяющийся код (boilerplate code) для обработки событий роутинга и
вызывает нужный метод у объекта контроллер. Содержит роуты, которые вызывают
методы у вашего объекта непосредственно. 

## Содержание

* [Настройка роутов](#configure-routes)
* [Настройка роутов в конструкторе](#configure-routes-in-constructor)
* [Добавление роутов при выполнения приложения](#add-routes-at-runtime)
* [Указание контроллера](#specify-a-controller)
* [Коллбэк onRoute](#onroute)

## <a name="configure-routes"></a> Настройка роутов

Для настройки роутера используется `appRoutes`. Определение роута осуществляется точно таким же образом, как и в роутере Backbone.
Однако, в отличие от Backbone, где роуту назначается один из методов самого роутера, в Marionette роуту назначается один из методов контроллера, указанного при создании роутера.  

```js
var MyRouter = Backbone.Marionette.AppRouter.extend({
  // "someMethod" должен существовать как controller.someMethod
  appRoutes: {
    "some/route": "someMethod"
  },

  /* Так же можно задать и обычные роуты */
  routes : {
    "some/otherRoute" : "someOtherMethod"
  },
  someOtherMethod : function(){
    // тело метода
  }

});
```

В `AppRouter` можно указать обычные роуты Backbone, но в этом случае методы-обработчики этих роутов должны определяться в самом роутере, а не в контроллере.

## <a name="configure-routes-in-constructor"></a> Настройка роутов в конструкторе

Также роуты могут быть определены с помощью аргументов функции конструктора.
Для этого констуктору нужно передать объект `appRoutes`.

```js
var myRouter = new Marionette.AppRouter({
  controller: myController,
  appRoutes: {
    "foo": "doFoo",
    "bar/:id": "doBar"
  }
});
```

Этот способ позволяет создать экземпляр роутера без использования
метода `.extend`.

## <a name="add-routes-at-runtime"></a> Добавление роутов при выполнения приложения

В дополнение к предварительной настройке через определение `appRoutes`,
роуты можно добавлять в момент выполнения приложения. Для этого нужно
воспользоваться методом `appRoute()`. Этот метод работает так же, как и
метод `router.route()` Backbone, но вторым аргументом в него передается
не обработчик роута, а имя метода обработчика из контроллера.

```js
var MyRouter = Marionette.AppRouter.extend({});

var router = new MyRouter();
router.appRoute("/foo", "fooThat");
```

Также при выполнении приложения с помощью метода `processAppRoutes` можно указать
контроллер с несколькими роутами. Однако, в этом случае текущий контроллер не будет
изменен.

```js
var MyRouter = Marionette.AppRouter.extend({});

var router = new MyRouter();
router.processAppRoutes(myController, {
  "foo": "doFoo",
  "bar/:id": "doBar"
});
```

## <a name="specify-a-controller"></a> Указание контроллера

Роутеры приложения могут использовать только один контроллер,
который может быть указан при определении роутера:

```js
someController = {
  someMethod: function(){ /*...*/ }
};

Marionette.AppRouter.extend({
  controller: someController
});
```

... или в качестве параметра конструктора:

```js
myObj = {
  someMethod: function(){ /*...*/ }
};

new MyRouter({
  controller: myObj
});
```

К объекту, который используется как `controller`, не предъявляются никакие
требования, за исключением того, что он должен содержать методы, которые были
указаны в качестве обработчиков в `appRoutes`.

Рекомендуется разделять ваши контроллеры на небольшие кусочки со связанной
функциональностью и иметь несколько роутеров / контроллеров вместо одного
большого роутера и контроллера.

## <a name="onroute"></a> Коллбэк `onRoute`

Если в роутере определен коллбэк `onRoute`, то он будет вызываться каждый раз,
когда пользователь совершит действие, которое изменит роут. Этот коллбэк
принимает три аргумента: имя, путь и параметры роута.