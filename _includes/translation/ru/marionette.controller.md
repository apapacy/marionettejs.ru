`Controller` это объект общего назначения в Marionette. Не смотря на свое название,
этот объект не имеет ничего общего с контроллером из паттерна MVC. В данном случае под
контроллером лучше понимать некий базовый объект.

Контроллеры следует использовать в случае, когда требуется объект, который будет выполнять
какую-либо конкретную задачу, для которой не подходит ни одни из классов Marionette.js.

## Содержание

* [Основное применение](#basic-use)
* [Выключение контроллера](#destroying-a-controller)
* [Метод `getOption`](#get-option)
* [Термин 'Controller'](#on-the-name-controller)

## <a name="basic-use"></a> Основное применение

Объект `Marionette.Controller` может быть унаследован так же как и объекты `Backbone` и `Marionette`.
Он поддерживет стандартный метод `initialize`, обладает встроенным `EventBinder`
и может самостоятельно вызывать события.

```js
// объявление контроллера
var MyController = Marionette.Controller.extend({
  initialize: function(options){
    this.stuff = options.stuff;
  },
  doStuff: function(){
    this.trigger("stuff:done", this.stuff);
  }
});

// создание экземпляра
var myController = new MyController({
  stuff: "some stuff"
});

// использование встроенного EventBinder
myController.listenTo(c, "stuff:done", function(stuff){
  console.log(stuff);
});

// вызов некоего функционала
myController.doStuff();
```

## <a name="get-option"></a> Метод `getOption`

Метод позволяет получить значение свойства контроллера. Это свойство может принадлежать как самому контроллеру непосредственно, так и 
быть вложенным в свойстве `this.options` контроллера. Если запрашиваемое свойство сущестует и в контроллере и в `this.options`, то метод вернет значение из `this.options`.
Для более полной информации ознакомьтесь с [getOption](../functions/).

## <a name="closing-a-controller"></a> Выключение контроллера

Каждый экземпляр контроллера имеет встроенный метод `destroy`,
который удаляет все обработчики событий, присоединенные к экземпляру контроллера, 
а также те, которые были навешаны с помощью `EventBinder`.

Вызов метода `destroy` запустит события "before:destroy" и "destroy" и вызовет
соответствующие методы `onBeforeDestroy` и `onDestroy`. В эти методы будут переданы
аргументы, с которыми был вызван метод `destroy`:

```js
// объявление контроллера с методом onDestroy
var MyController = Marionette.Controller.extend({

  onBeforeDestroy: function(arg1, arg2){
    // код в этом месте будет выполнен до выключения контроллера
  }

  onDestroy: function(arg1, arg2){
    // код в этом месте будет обрабатывать выключение контроллера
  }

});

// создание нового экземпляра контроллера
var myController = new MyController();

// добавление нескольких обработчиков событий
myController.on("before:destroy", function(arg1, arg2){ ... });
myController.on("destroy", function(arg1, arg2){ ... });
myController.listenTo(something, "bar", function(){...});

// выключение контроллера: отписываемся от всех событий,
// вызов события "destroy" и метода onDestroy
myController.destroy(arg1, arg2);
```

## <a name="on-the-name-controller"></a> Термин 'Controller'

Сам термин `Controller` может вызвать некоторое замешательство, потому что оно довольно неудачный.
Было много обсуждений и споров о том, как назвать этот объект. Вполне возможно, что пользователи будут путать
этот объект с контроллером из паттерна MVC. В конце концов, было принято решение все-таки назвать его
контроллером потому, что типичным примером его использования может служить управление работой приложения и/или его модуля.

Но суть в том, что в широком понимании это многоцелевой объект, который может выполнять много
различных ролей при многих различных сценариях. Разработчики всегда открыты для предложений (с обоснованием и
после обсуждения) о именовании объектов с целью сделать библиотеку более понятной и менее запутанной.
Если вы хотите предложить какое-то иное имя для этого объекта, то просто создайте issue в
[официальном репозитории](https://github.com/marionettejs/backbone.marionette) Marionette на Github.